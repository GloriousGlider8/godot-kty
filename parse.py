import yaml
import click
import colorama as c
from pathlib import Path

# welcome to my basically unreadable python script that compiles ksy files to gdscript classes
# theres a very limited featureset for now so if u want to contribute, please do!

# we use camel case because its what i use in gdscript :)
def snake_to_camel(s):
	parts = s.split('_')
	return parts[0] + ''.join(word.capitalize() for word in parts[1:])

def parse_type(field_type, repeat):
	if repeat:
		return "[]"
	elif field_type == "b1":
		return "false"
	elif field_type.startswith("u") or field_type.startswith("b"):
		return "0"
	elif field_type.startswith("str"):
		return '""'
	else:
		return f'null # could not infer type ({field_type})'

def generate_godot_class(ksy):
	warns = []
	lines = []
	lines.append(f"class_name {snake_to_camel(ksy['meta']['id'].upper())} extends Node\n\n# DYNAMICALLY GENERATED SCRIPT\n# This script was generated by the WIP Godot Kaitai Struct compiler written by GloriousGlider8\n# To support the project, check me out on GitHub at https://github.com/GloriousGlider8\n")
	lines.append("""func NULPAD(data: PackedByteArray, target_size: int) -> PackedByteArray:
	if data.size() >= target_size:
    	data.resize(target_size)
		return data
	for i in range(target_size - data.size()):
		data.append(0)
	return data
""")

	# Variables
	for field in ksy.get("seq", []):
		field_id = field['id']
		var_default = parse_type(field['type'], field.get("repeat"))
		lines.append(f"var {snake_to_camel(field_id)} = {var_default}")

	# Instances
	for inst_id in ksy.get("instances", {}):
		lines.append(f"var {snake_to_camel(inst_id)}")

	lines.append("\nfunc from_file(file: FileAccess):")
	lines.append("\tfile.big_endian = " + str(ksy["meta"].get("endian", "le") == "be").lower())
	lines.append("\tvar bm_readbyte # bitmode current byte data\n\t\n\t# Sequences")

	# Load sequence (the big block of code that basically does all the heavy lifting)
	inbitmode = False
	bmoffset = 0
	for field in ksy.get("seq", []):
		id_ = snake_to_camel(field['id'])
		type_ = field['type']
		if type_.endswith("le") and ksy["meta"].get("endian", "le") == "be":
			lines.append("\tfile.big_endian = false")
		inrepeat = False
		if "repeat" in field:
			inrepeat = True
			lines.append(f"\tfor i in {field['repeat-expr']}:")
		if type_[0] == "b" and not inbitmode:
			inbitmode = True
			bmoffset = 0
			lines.append("\tbm_readbyte = file.get_8() # get next byte for bitmode")
		match type_[0]:
			case "u" if type_.removeprefix("u").removesuffix("le") in ("1", "2", "4", "8"):
				if inrepeat:
					lines.append(f'\t\t{id_}.append(file.get_{int(type_.removeprefix("u").removesuffix("le")) * 8}()) # {type_}')
				else:
					lines.append(f'\t{id_} = file.get_{int(type_.removeprefix("u").removesuffix("le")) * 8}() # {type_}')
			case "s" if type_ == "str":
				if field["encoding"].removesuffix("le") not in ("ascii", "utf-8", "utf-16", "utf-32"):
					warns.append(f'String encoding {field["encoding"]} is not supported.\n\tPlease use ascii, utf-8, utf-16 or utf-32 (or le variants).')
				else:
					tmp = ""
					if inrepeat:
						tmp = f'\t\t{id_}.append(file.get_buffer({str(field["size"])}).get_string_from_{"".join(field["encoding"].removesuffix("le").split("-"))}()) # {type_}'
					else:
						tmp = f'\t{id_} = file.get_buffer({str(field["size"])}).get_string_from_{"".join(field["encoding"].removesuffix("le").split("-"))}() # {type_}'
					if field["encoding"].endswith("le") and ksy["meta"].get("endian", "le") == "be":
						tmp = "\tfile.big_endian = false\n" + tmp + "\n\tfile.big_endian = true"
					lines.append(tmp)
			case "s" if type_.removeprefix("s").removesuffix("le") in ("1", "2", "4", "8"):
				warns.append("signed integers not supported at the moment :/ (note to self: check docs for packedbytearray)\n\tSee https://github.com/godotengine/godot-proposals/issues/11316 for more info.")
			case "b":
				if int(type_.removeprefix("b")) > 8 - bmoffset:
					warns.append(f"Bitmode cannot go past the byte boundry.\n\t{id_} at offset {str(bmoffset)}bt tried to read {type_.removeprefix('b')}bt.")
				elif not inbitmode:
					warns.append(f'Bitmode not initalised for {id_}! (probably caused by a script error)')
				else:
					if inrepeat:
						lines.append(f'\t{id_}.append((bm_readbyte >> {str(bmoffset)}) & 0b{"0" * (8 - int(type_.removeprefix("b")))}{"1" * int(type_.removeprefix("b"))}) # {type_}')
					else:
						lines.append(f'\t{id_} = ((bm_readbyte >> {str(bmoffset)}) & 0b{"0" * (8 - int(type_.removeprefix("b")))}{"1" * int(type_.removeprefix("b"))}){" == 1" if type_ == "b1" else ""} # {type_}')
					bmoffset += int(type_.removeprefix("b"))
					if bmoffset == 8:
						inbitmode = False
			case _:
				warns.append(f'The type assigned to {id_} ({type_}) is not supported.')

	# Decode instances
	lines.append("\n\t# Instances")
	for name, inst in ksy.get("instances", {}).items():
		prop = snake_to_camel(name)
		expr = inst['value']
		e1 = expr.split("&")
		lines.append(f'\t{prop} = ({snake_to_camel(e1[0].removesuffix(" "))}) & {e1[1].removeprefix(" ")}')

	# Write sequences
	lines.append("\nfunc to_file(file: FileAccess):")
	lines.append("\tfile.big_endian = " + str(ksy["meta"].get("endian", "le") == "be").lower())
	lines.append("\tvar bm_readbyte # bitmode current byte data\n\t\n\t# Sequences")
	for field in ksy.get("seq", []):
		id_ = snake_to_camel(field['id'])
		type_ = field['type']
		if type_.endswith("le") and ksy["meta"].get("endian", "le") == "be":
			lines.append("\tfile.big_endian = false")
		inrepeat = False
		if "repeat" in field:
			inrepeat = True
			lines.append(f"\tfor i in {field['repeat-expr']}:")
		if type_[0] == "b" and not inbitmode:
			inbitmode = True
			bmoffset = 0
			lines.append("\tbm_readbyte = 0 # make next byte for bitmode")
		match type_[0]:
			case "u" if type_.removeprefix("u").removesuffix("le") in ("1", "2", "4", "8"):
				if inrepeat:
					lines.append(f'\t\tfile.store_{int(type_.removeprefix("u").removesuffix("le")) * 8}({id_}[i]) # {type_}')
				else:
					lines.append(f'\tfile.store_{int(type_.removeprefix("u").removesuffix("le")) * 8}({id_}) # {type_}')
			case "s" if type_ == "str":
				if field["encoding"].removesuffix("le") not in ("ascii", "utf-8", "utf-16", "utf-32"):
					warns.append(f'String encoding {field["encoding"]} is not supported.\n\tPlease use ascii, utf-8, utf-16 or utf-32 (or le variants).')
				else:
					tmp = ""
					if inrepeat:
						tmp = f'\t\tfile.store_buffer(NULPAD({id_}[i].to_{"".join(field["encoding"].removesuffix("le").split("-"))}_buffer(), {str(field["size"])})) # {type_}'
					else:
						tmp = f'\tfile.store_buffer(NULPAD({id_}.to_{"".join(field["encoding"].removesuffix("le").split("-"))}_buffer(), {str(field["size"])})) # {type_}'
					if field["encoding"].endswith("le") and ksy["meta"].get("endian", "le") == "be":
						tmp = "\tfile.big_endian = false\n" + tmp + "\n\tfile.big_endian = true"
					lines.append(tmp)
			case "s" if type_.removeprefix("s").removesuffix("le") in ("1", "2", "4", "8"):
				warns.append("signed integers not supported at the moment :/ (note to self: check docs for packedbytearray)\n\tSee https://github.com/godotengine/godot-proposals/issues/11316 for more info.")
			case "b":
				if int(type_.removeprefix("b")) > 8 - bmoffset:
					warns.append(f"Bitmode cannot go past the byte boundry.\n\t{id_} at offset {str(bmoffset)}bt tried to read {type_.removeprefix('b')}bt.")
				elif not inbitmode:
					warns.append(f'Bitmode not initalised for {id_}! (probably caused by a script error)')
				else:
					if inrepeat:
						lines.append(f'\t\tbm_readbyte |= ({id_}[i] << {str(bmoffset)}) # {type_}')
					else:
						lines.append(f'\tbm_readbyte |= ({id_} << {str(bmoffset)}) # {type_}')
					bmoffset += int(type_.removeprefix("b"))
					if bmoffset == 8:
						lines.append(f'\tfile.store_8(bm_readbyte)')
						inbitmode = False
			case _:
				warns.append(f'The type assigned to {id_} ({type_}) is not supported.')

	for w in warns:
		print(f'{c.Fore.YELLOW}{c.Style.BRIGHT}[WRN]{c.Style.RESET_ALL}{c.Fore.YELLOW} {w}{c.Style.RESET_ALL}')
	print(f'{c.Fore.BLUE}{c.Style.BRIGHT}[INF]{c.Style.RESET_ALL}{c.Fore.BLUE} All invalid fields will be ignored.{c.Style.RESET_ALL}')
	return "\n".join(lines)

@click.command()
@click.option("-I", help="Input Kaitai Struct (KSY) file. MUST be in strictly valid YAML.")
@click.option("-O", default="out.gd", help="Output GDScript (GD) file.")
def conv(i, o):
	if not i:
		print(f'{c.Fore.BLUE}{c.Style.BRIGHT}[INF]{c.Style.RESET_ALL}{c.Fore.BLUE} Please specify an argument or use --help for help.{c.Style.RESET_ALL}')
		exit(0)
	path = Path(i)
	if "\t" in path.read_text():
		print(f"{c.Fore.RED}{c.Style.BRIGHT}[ERR]{c.Style.RESET_ALL}{c.Fore.RED} Please replace all tabs in your file with 2 spaces.{c.Style.RESET_ALL}")
		exit(1)
	ksy = yaml.safe_load(path.read_text())
	script = generate_godot_class(ksy)
	with open(o, "w") as f:
		f.write(script)
	print(f"{c.Fore.BLUE}{c.Style.BRIGHT}[INF]{c.Style.RESET_ALL}{c.Fore.BLUE} Written output to {o}{c.Style.RESET_ALL}")
	exit(0)

conv()